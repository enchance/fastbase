{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Usage","text":"<p>Hello there</p>"},{"location":"class/fastbase-dependency/","title":"FastbaseDependency","text":"Source code in <code>fastbase/main.py</code> <pre><code>class FastbaseDependency:\n    engine: AsyncEngine\n    User: Type[USER]\n\n    # TESTME: Untested\n    @staticmethod\n    def verify_idtoken(authorization: Annotated[str, Header()]) -&gt; str:\n        \"\"\"\n        Dependency to verify if a Google **idtoken** is valid. Out of the decrypted data only the email is returned.\n\n        !!! tip \"Use with\"\n            Use with the `current_user` dependency which gets the User based on the email.\n\n        ??? example\n\n            ```python\n            @app.get('/', email: Annotated[str, Depends(verify_idtoken)]):\n                # Header:  Authorization=Bearer abc123...\n                ...\n            ```\n\n        :param authorization:   Bearer token taken taken from Google idtoken\n        :return:                Decrypted token data\n        :raises InvalidToken:   Token cannot be used e.g. it's expired, malformed, etc.\n        \"\"\"\n        try:\n            token = authorization.split(' ')[1]\n            token_data = auth.verify_id_token(token)\n            return token_data.pop('email')\n        except Exception:\n            raise InvalidToken()\n\n    # TESTME: Untested\n    async def current_user(self, email: Annotated[str, Depends(verify_idtoken)]) -&gt; Type[USER]:\n        \"\"\"\n        Dependency for getting the user by their verified idtoken.\n\n        !!! tip \"Use with\"\n            Use with the `verify_idtoken` dependency which gets the User based on the email.\n\n        ??? example\n\n            ```python\n            @app.get('/', user: Annotated[User, Depends(current_user)]):\n                ...\n            ```\n        :param email:   Email taken from the bearer token\n        :return:        Valid user\n        :raises UserNotFoundError:  The user who owns the email doesn't exist\n        \"\"\"\n        try:\n            async with self.async_session() as session:                 # noqa\n                user = await self.User.get_by_email(session, email)\n                return user\n        except Exception as _:\n            raise UserNotFoundError()\n</code></pre>"},{"location":"class/fastbase-dependency/#fastbase.FastbaseDependency-attributes","title":"Attributes","text":""},{"location":"class/fastbase-dependency/#fastbase.FastbaseDependency.User","title":"<code>User: Type[USER]</code>  <code>instance-attribute</code>","text":""},{"location":"class/fastbase-dependency/#fastbase.FastbaseDependency.engine","title":"<code>engine: AsyncEngine</code>  <code>instance-attribute</code>","text":""},{"location":"class/fastbase-dependency/#fastbase.FastbaseDependency-functions","title":"Functions","text":""},{"location":"class/fastbase-dependency/#fastbase.FastbaseDependency.current_user","title":"<code>current_user(email)</code>  <code>async</code>","text":"<p>Dependency for getting the user by their verified idtoken.</p> <p>Use with</p> <p>Use with the <code>verify_idtoken</code> dependency which gets the User based on the email.</p> Example <pre><code>@app.get('/', user: Annotated[User, Depends(current_user)]):\n    ...\n</code></pre> PARAMETER  DESCRIPTION <code>email</code> <p>Email taken from the bearer token</p> <p> TYPE: <code>Annotated[str, Depends(verify_idtoken)]</code> </p> RETURNS DESCRIPTION <code>Type[USER]</code> <p>Valid user</p> RAISES DESCRIPTION <code>UserNotFoundError</code> <p>The user who owns the email doesn't exist</p> Source code in <code>fastbase/main.py</code> <pre><code>async def current_user(self, email: Annotated[str, Depends(verify_idtoken)]) -&gt; Type[USER]:\n    \"\"\"\n    Dependency for getting the user by their verified idtoken.\n\n    !!! tip \"Use with\"\n        Use with the `verify_idtoken` dependency which gets the User based on the email.\n\n    ??? example\n\n        ```python\n        @app.get('/', user: Annotated[User, Depends(current_user)]):\n            ...\n        ```\n    :param email:   Email taken from the bearer token\n    :return:        Valid user\n    :raises UserNotFoundError:  The user who owns the email doesn't exist\n    \"\"\"\n    try:\n        async with self.async_session() as session:                 # noqa\n            user = await self.User.get_by_email(session, email)\n            return user\n    except Exception as _:\n        raise UserNotFoundError()\n</code></pre>"},{"location":"class/fastbase-dependency/#fastbase.FastbaseDependency.verify_idtoken","title":"<code>verify_idtoken(authorization)</code>  <code>staticmethod</code>","text":"<p>Dependency to verify if a Google idtoken is valid. Out of the decrypted data only the email is returned.</p> <p>Use with</p> <p>Use with the <code>current_user</code> dependency which gets the User based on the email.</p> Example <pre><code>@app.get('/', email: Annotated[str, Depends(verify_idtoken)]):\n    # Header:  Authorization=Bearer abc123...\n    ...\n</code></pre> PARAMETER  DESCRIPTION <code>authorization</code> <p>Bearer token taken taken from Google idtoken</p> <p> TYPE: <code>Annotated[str, Header()]</code> </p> RETURNS DESCRIPTION <code>str</code> <p>Decrypted token data</p> RAISES DESCRIPTION <code>InvalidToken</code> <p>Token cannot be used e.g. it's expired, malformed, etc.</p> Source code in <code>fastbase/main.py</code> <pre><code>@staticmethod\ndef verify_idtoken(authorization: Annotated[str, Header()]) -&gt; str:\n    \"\"\"\n    Dependency to verify if a Google **idtoken** is valid. Out of the decrypted data only the email is returned.\n\n    !!! tip \"Use with\"\n        Use with the `current_user` dependency which gets the User based on the email.\n\n    ??? example\n\n        ```python\n        @app.get('/', email: Annotated[str, Depends(verify_idtoken)]):\n            # Header:  Authorization=Bearer abc123...\n            ...\n        ```\n\n    :param authorization:   Bearer token taken taken from Google idtoken\n    :return:                Decrypted token data\n    :raises InvalidToken:   Token cannot be used e.g. it's expired, malformed, etc.\n    \"\"\"\n    try:\n        token = authorization.split(' ')[1]\n        token_data = auth.verify_id_token(token)\n        return token_data.pop('email')\n    except Exception:\n        raise InvalidToken()\n</code></pre>"},{"location":"class/fastbase/","title":"Fastbase","text":"<p>             Bases: <code>FastbaseDependency</code></p> Source code in <code>fastbase/main.py</code> <pre><code>class Fastbase(FastbaseDependency):\n    _instance = None\n    _lock = threading.Lock()\n    async_session: AsyncSession\n    User: Type[USER]\n\n    def __new__(cls):\n        \"\"\"\n        Singleton pattern\n        !!! note\n            - [https://stackabuse.com/creating-a-singleton-in-python/](https://stackabuse.com/creating-a-singleton-in-python/)\n            - [https://chat.openai.com/c/1305cb84-5417-4bbb-86b7-401346f846c9](https://chat.openai.com/c/1305cb84-5417-4bbb-86b7-401346f846c9)\n            - [https://bard.google.com/chat/e2fcdd7109d1a5c0](https://bard.google.com/chat/e2fcdd7109d1a5c0)\n        \"\"\"\n        with cls._lock:\n            if not cls._instance:\n                cls._instance = super().__new__(cls)\n        return cls._instance\n\n    # TESTME: Untested\n    def initialize(self, *, async_session: AsyncSession, user_model: Type[USER]):\n        \"\"\"Use instead of __init__ since it uses the singleton pattern.\"\"\"\n        self.async_session = async_session\n        self.User = user_model\n</code></pre>"},{"location":"class/fastbase/#fastbase.Fastbase-attributes","title":"Attributes","text":""},{"location":"class/fastbase/#fastbase.Fastbase.User","title":"<code>User: Type[USER]</code>  <code>instance-attribute</code>","text":""},{"location":"class/fastbase/#fastbase.Fastbase.async_session","title":"<code>async_session: AsyncSession</code>  <code>instance-attribute</code>","text":""},{"location":"class/fastbase/#fastbase.Fastbase-functions","title":"Functions","text":""},{"location":"class/fastbase/#fastbase.Fastbase.__new__","title":"<code>__new__()</code>","text":"<p>Singleton pattern</p> <p>Note</p> <ul> <li>https://stackabuse.com/creating-a-singleton-in-python/</li> <li>https://chat.openai.com/c/1305cb84-5417-4bbb-86b7-401346f846c9</li> <li>https://bard.google.com/chat/e2fcdd7109d1a5c0</li> </ul> Source code in <code>fastbase/main.py</code> <pre><code>def __new__(cls):\n    \"\"\"\n    Singleton pattern\n    !!! note\n        - [https://stackabuse.com/creating-a-singleton-in-python/](https://stackabuse.com/creating-a-singleton-in-python/)\n        - [https://chat.openai.com/c/1305cb84-5417-4bbb-86b7-401346f846c9](https://chat.openai.com/c/1305cb84-5417-4bbb-86b7-401346f846c9)\n        - [https://bard.google.com/chat/e2fcdd7109d1a5c0](https://bard.google.com/chat/e2fcdd7109d1a5c0)\n    \"\"\"\n    with cls._lock:\n        if not cls._instance:\n            cls._instance = super().__new__(cls)\n    return cls._instance\n</code></pre>"},{"location":"class/fastbase/#fastbase.Fastbase.initialize","title":"<code>initialize(*, async_session, user_model)</code>","text":"<p>Use instead of init since it uses the singleton pattern.</p> Source code in <code>fastbase/main.py</code> <pre><code>def initialize(self, *, async_session: AsyncSession, user_model: Type[USER]):\n    \"\"\"Use instead of __init__ since it uses the singleton pattern.\"\"\"\n    self.async_session = async_session\n    self.User = user_model\n</code></pre>"},{"location":"models/group/","title":"Group","text":"<p>             Bases: <code>IntPK</code>, <code>UpdatedAtMixin</code>, <code>SQLModel</code></p> Source code in <code>fastbase/models/rbac.py</code> <pre><code>class Group(IntPK, UpdatedAtMixin, SQLModel, table=True):\n    __tablename__ = 'auth_group'\n    name: str = Field(max_length=20, unique=True)\n    description: str = Field(max_length=199, default='')\n    permissions: list[str] = Field(sa_column=Column(ARRAY(String)), default=[])\n\n    def __repr__(self):\n        return modstr(self, 'name')\n\n    @classmethod\n    async def create(cls, session: AsyncSession, *,\n                     name: str,  permissions: set | None = None,\n                     description: str | None = None) -&gt; Self:\n        \"\"\"Create a new group. Requires group.create permission.\"\"\"\n        try:\n            group = cls(name=name, permissions=permissions, description=description)\n            session.add(group)\n            await session.commit()\n            await session.refresh(group)\n            return group\n        except IntegrityError:\n            raise\n\n    # PLACEHOLDER: To follow\n    @classmethod\n    async def delete(cls, name: str):\n        \"\"\"Delete a group. Updates cache.\"\"\"\n        pass\n\n    async def add_all(self, session: AsyncSession, permissions: set[str]):\n        \"\"\"Append new permissions to group. Requires group.update permission.\"\"\"\n        self.permissions = {*self.permissions, *permissions}                # noqa\n        session.add(self)\n        await session.commit()\n\n    async def reset(self, session: AsyncSession, permissions: set[str] | None = None):\n        \"\"\"Reset permissions. Requires group.reset permission.\"\"\"\n        self.permissions = permissions or []\n        session.add(self)\n        await session.commit()\n\n    async def describe(self, session: AsyncSession, description: str | None = None):\n        \"\"\"Change group description. Requires group.update permission.\"\"\"\n        self.description = description or ''\n        await session.commit()\n\n    # TESTME: Untested\n    @classmethod\n    async def collate(cls, session: AsyncSession, nameset: set[str]) -&gt; set[str]:\n        stmt = select(cls.permissions).where(cls.name.in_(nameset))     # noqa\n        edata = await session.exec(stmt)\n        alldata = edata.all()\n\n        ss = set()\n        for i in alldata:\n            ss.update(i)\n        return ss\n</code></pre>"},{"location":"models/group/#fastbase.models.rbac.Group-attributes","title":"Attributes","text":""},{"location":"models/group/#fastbase.models.rbac.Group.__tablename__","title":"<code>__tablename__ = 'auth_group'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"models/group/#fastbase.models.rbac.Group.description","title":"<code>description: str = Field(max_length=199, default='')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"models/group/#fastbase.models.rbac.Group.name","title":"<code>name: str = Field(max_length=20, unique=True)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"models/group/#fastbase.models.rbac.Group.permissions","title":"<code>permissions: list[str] = Field(sa_column=Column(ARRAY(String)), default=[])</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"models/group/#fastbase.models.rbac.Group-functions","title":"Functions","text":""},{"location":"models/group/#fastbase.models.rbac.Group.__repr__","title":"<code>__repr__()</code>","text":"Source code in <code>fastbase/models/rbac.py</code> <pre><code>def __repr__(self):\n    return modstr(self, 'name')\n</code></pre>"},{"location":"models/group/#fastbase.models.rbac.Group.add_all","title":"<code>add_all(session, permissions)</code>  <code>async</code>","text":"<p>Append new permissions to group. Requires group.update permission.</p> Source code in <code>fastbase/models/rbac.py</code> <pre><code>async def add_all(self, session: AsyncSession, permissions: set[str]):\n    \"\"\"Append new permissions to group. Requires group.update permission.\"\"\"\n    self.permissions = {*self.permissions, *permissions}                # noqa\n    session.add(self)\n    await session.commit()\n</code></pre>"},{"location":"models/group/#fastbase.models.rbac.Group.collate","title":"<code>collate(session, nameset)</code>  <code>async</code> <code>classmethod</code>","text":"Source code in <code>fastbase/models/rbac.py</code> <pre><code>@classmethod\nasync def collate(cls, session: AsyncSession, nameset: set[str]) -&gt; set[str]:\n    stmt = select(cls.permissions).where(cls.name.in_(nameset))     # noqa\n    edata = await session.exec(stmt)\n    alldata = edata.all()\n\n    ss = set()\n    for i in alldata:\n        ss.update(i)\n    return ss\n</code></pre>"},{"location":"models/group/#fastbase.models.rbac.Group.create","title":"<code>create(session, *, name, permissions=None, description=None)</code>  <code>async</code> <code>classmethod</code>","text":"<p>Create a new group. Requires group.create permission.</p> Source code in <code>fastbase/models/rbac.py</code> <pre><code>@classmethod\nasync def create(cls, session: AsyncSession, *,\n                 name: str,  permissions: set | None = None,\n                 description: str | None = None) -&gt; Self:\n    \"\"\"Create a new group. Requires group.create permission.\"\"\"\n    try:\n        group = cls(name=name, permissions=permissions, description=description)\n        session.add(group)\n        await session.commit()\n        await session.refresh(group)\n        return group\n    except IntegrityError:\n        raise\n</code></pre>"},{"location":"models/group/#fastbase.models.rbac.Group.delete","title":"<code>delete(name)</code>  <code>async</code> <code>classmethod</code>","text":"<p>Delete a group. Updates cache.</p> Source code in <code>fastbase/models/rbac.py</code> <pre><code>@classmethod\nasync def delete(cls, name: str):\n    \"\"\"Delete a group. Updates cache.\"\"\"\n    pass\n</code></pre>"},{"location":"models/group/#fastbase.models.rbac.Group.describe","title":"<code>describe(session, description=None)</code>  <code>async</code>","text":"<p>Change group description. Requires group.update permission.</p> Source code in <code>fastbase/models/rbac.py</code> <pre><code>async def describe(self, session: AsyncSession, description: str | None = None):\n    \"\"\"Change group description. Requires group.update permission.\"\"\"\n    self.description = description or ''\n    await session.commit()\n</code></pre>"},{"location":"models/group/#fastbase.models.rbac.Group.reset","title":"<code>reset(session, permissions=None)</code>  <code>async</code>","text":"<p>Reset permissions. Requires group.reset permission.</p> Source code in <code>fastbase/models/rbac.py</code> <pre><code>async def reset(self, session: AsyncSession, permissions: set[str] | None = None):\n    \"\"\"Reset permissions. Requires group.reset permission.\"\"\"\n    self.permissions = permissions or []\n    session.add(self)\n    await session.commit()\n</code></pre>"},{"location":"models/role/","title":"Role","text":"<p>             Bases: <code>IntPK</code>, <code>UpdatedAtMixin</code>, <code>SQLModel</code></p> Source code in <code>fastbase/models/rbac.py</code> <pre><code>class Role(IntPK, UpdatedAtMixin, SQLModel, table=True):\n    __tablename__ = 'auth_role'\n    name: str = Field(max_length=20, unique=True)\n    description: str | None = Field(max_length=199, default='')\n    groups: list[str] = Field(sa_column=Column(ARRAY(String)), default=[])\n\n    def __repr__(self):\n        return modstr(self, 'name', 'description')\n\n    # TESTME: Untested\n    @classmethod\n    async def create(cls, session: AsyncSession, *, name:str, groups: set, description: str | None = None) -&gt; Self:\n        \"\"\"Create new role. Requires the role.create permission.\"\"\"\n        try:\n            role = cls(name=name, groups=groups, description=description)\n            session.add(role)\n            await session.commit()\n            await session.refresh(role)\n            return role\n        except IntegrityError:\n            raise\n\n    # TESTME: Untested\n    @classmethod\n    async def reset(cls, session: AsyncSession, id: int, groups: set) -&gt; Self:\n        \"\"\"Reset groups. Requires role.reset permission.\"\"\"\n        if role := await session.get(cls, id):\n            role.groups = groups\n            session.add(role)\n            await session.commit()\n        return role\n\n    # TESTME: Untested\n    @classmethod\n    async def describe(cls, session: AsyncSession, id: int, description: str) -&gt; Self:\n        \"\"\"Change role description. Requires role.update permission.\"\"\"\n        if role := await session.get(cls, id):\n            role.description = description\n            session.add(role)\n            await session.commit()\n        return role\n</code></pre>"},{"location":"models/role/#fastbase.models.rbac.Role-attributes","title":"Attributes","text":""},{"location":"models/role/#fastbase.models.rbac.Role.__tablename__","title":"<code>__tablename__ = 'auth_role'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"models/role/#fastbase.models.rbac.Role.description","title":"<code>description: str | None = Field(max_length=199, default='')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"models/role/#fastbase.models.rbac.Role.groups","title":"<code>groups: list[str] = Field(sa_column=Column(ARRAY(String)), default=[])</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"models/role/#fastbase.models.rbac.Role.name","title":"<code>name: str = Field(max_length=20, unique=True)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"models/role/#fastbase.models.rbac.Role-functions","title":"Functions","text":""},{"location":"models/role/#fastbase.models.rbac.Role.__repr__","title":"<code>__repr__()</code>","text":"Source code in <code>fastbase/models/rbac.py</code> <pre><code>def __repr__(self):\n    return modstr(self, 'name', 'description')\n</code></pre>"},{"location":"models/role/#fastbase.models.rbac.Role.create","title":"<code>create(session, *, name, groups, description=None)</code>  <code>async</code> <code>classmethod</code>","text":"<p>Create new role. Requires the role.create permission.</p> Source code in <code>fastbase/models/rbac.py</code> <pre><code>@classmethod\nasync def create(cls, session: AsyncSession, *, name:str, groups: set, description: str | None = None) -&gt; Self:\n    \"\"\"Create new role. Requires the role.create permission.\"\"\"\n    try:\n        role = cls(name=name, groups=groups, description=description)\n        session.add(role)\n        await session.commit()\n        await session.refresh(role)\n        return role\n    except IntegrityError:\n        raise\n</code></pre>"},{"location":"models/role/#fastbase.models.rbac.Role.describe","title":"<code>describe(session, id, description)</code>  <code>async</code> <code>classmethod</code>","text":"<p>Change role description. Requires role.update permission.</p> Source code in <code>fastbase/models/rbac.py</code> <pre><code>@classmethod\nasync def describe(cls, session: AsyncSession, id: int, description: str) -&gt; Self:\n    \"\"\"Change role description. Requires role.update permission.\"\"\"\n    if role := await session.get(cls, id):\n        role.description = description\n        session.add(role)\n        await session.commit()\n    return role\n</code></pre>"},{"location":"models/role/#fastbase.models.rbac.Role.reset","title":"<code>reset(session, id, groups)</code>  <code>async</code> <code>classmethod</code>","text":"<p>Reset groups. Requires role.reset permission.</p> Source code in <code>fastbase/models/rbac.py</code> <pre><code>@classmethod\nasync def reset(cls, session: AsyncSession, id: int, groups: set) -&gt; Self:\n    \"\"\"Reset groups. Requires role.reset permission.\"\"\"\n    if role := await session.get(cls, id):\n        role.groups = groups\n        session.add(role)\n        await session.commit()\n    return role\n</code></pre>"},{"location":"models/usermod/","title":"UserMod","text":"<p>             Bases: <code>DTMixin</code>, <code>UuidPK</code>, <code>SQLModel</code></p> Source code in <code>fastbase/models/UserMod.py</code> <pre><code>class UserMod(DTMixin, UuidPK, SQLModel):\n    email: str = Field(max_length=190, unique=True)\n    username: str = Field(max_length=190, unique=True)\n    display: str = Field(max_length=199)\n    timezone: str | None = Field(max_length=190, default='+0000')\n\n    role: str = Field(max_length=20, default='user')\n    groups: list[str] = Field(sa_column=Column(ARRAY(String)), default=[])\n    permissions: list[str] = Field(sa_column=Column(ARRAY(String)), default=[])\n\n    is_verified: bool = Field(default=True)                     # TODO: Optional verification\n    is_active: bool = Field(default=True)                       # TODO: Optional activation\n    banned_at: datetime | None = Field(sa_column=Column(DateTime(timezone=True), nullable=True, index=True))\n\n    def __repr__(self):\n        return modstr(self, 'email')\n\n    @property\n    def is_super(self) -&gt; bool:\n        return self.role == 'super'\n\n    # TESTME: Untested\n    @classmethod\n    async def get_by_email(cls, session: AsyncSession, email: str) -&gt; Type[Self]:\n        raise NotImplementedError()\n\n    # TESTME: Untested\n    @classmethod\n    async def exists(cls, session: AsyncSession, email: EmailStr) -&gt; bool:\n        \"\"\"Check if a user exists\"\"\"\n        stmt = select(cls.id).where(cls.email == email)\n        execdata = await session.exec(stmt)\n        if _ := execdata.first():\n            return True\n\n    async def has(self, data: str) -&gt; bool:\n        raise NotImplementedError()\n\n    async def attach_group(self, session: AsyncSession, recipient: Self, name: str,\n                           *, caching: Callable[[str, list], None] | None = None,\n                           async_callback: Callable[[str, list], Awaitable[None]] | None = None):\n        \"\"\"\n        Attach a group to user. Prevents duplicates.\n        :param session:     AsyncSession\n        :param recipient:   The user to recieve the group\n        :param name:        Group name\n        :param caching:     Callback for caching data\n        :param async_callback:    Async callback for generic use\n        :raises PermissionsException:\n        :return:            None\n        \"\"\"\n        # async with AsyncSession(async_engine) as sess:\n        # async with asynccontextmanager(get_session)() as sess:\n        #     user = await User.get_by_email(sess, 'admin@gmail.com', skip_cache=True)\n        def _attach(name_: str) -&gt; list[str]:\n            neg_ = f'-{name_}'\n            groups_ = set(recipient.groups)\n\n            if neg_ in groups_:\n                groups_.remove(neg_)\n            elif name_ not in groups_:\n                groups_.add(name_)\n            return list(groups_)\n\n        if not await self.has('group.attach'):\n            raise PermissionsException()\n\n        if not name.strip():\n            return\n\n        if not self.is_super and self.email == recipient.email:\n            raise AppException('ILLEGAL_ACTION: You cannot modify your own groups.')\n\n        groups = _attach(name)\n        recipient.groups = groups\n        await session.commit()\n\n        if caching:\n            caching(recipient.email, groups)\n        if async_callback:\n            await async_callback(recipient.email, groups)\n\n    async def detach_group(self, session: AsyncSession, recipient: Self, name: str,\n                           *, caching: Callable[[str, list], None] | None = None,\n                           async_callback: Callable[[str, list], Awaitable[None]] | None = None):\n        \"\"\"\n        Remove a group from user. If the group is a starter group (can't be removed) then a negation is added.\n        :param session:     AsyncSession\n        :param recipient:   The user who's group is to be removed\n        :param name:        Group name\n        :param caching:     Callback for caching data\n        :param async_callback:    Async callback for generic use\n        :raises PermissionsException:\n        :return:            None\n        \"\"\"\n        def _detach(name_: str) -&gt; list[str]:\n            neg_ = f'-{name_}'\n            groups_ = set(recipient.groups)\n\n            if name_ in groups_:\n                groups_.remove(name_)\n            else:\n                groups_.add(neg_)\n            return list(groups_)\n\n        if not await self.has('group.detach'):\n            raise PermissionsException()\n\n        if not name.strip():\n            return\n\n        if not self.is_super and self.email == recipient.email:\n            raise AppException('ILLEGAL_ACTION: You cannot modify your own groups.')\n\n        groups = _detach(name)\n        recipient.groups = groups\n        await session.commit()\n\n        if caching:\n            caching(recipient.email, list(groups))\n        if async_callback:\n            await async_callback(recipient.email, list(groups))\n\n    async def attach_permission(self, session: AsyncSession, recipient: Self, perm: str,\n                                *, caching: Callable[[str, list], None] | None = None,\n                                async_callback: Callable[[str, list], Awaitable[None]] | None = None):\n        \"\"\"\n        Attach a permission to user. Prevents duplicates.\n        :param session:     AsyncSession\n        :param recipient:   The user to recieve the group\n        :param perm:        Permission\n        :param caching:     Callback for caching data\n        :param async_callback:    Async callback for generic use\n        :raises PermissionsException:\n        :return:            None\n        \"\"\"\n        # async with AsyncSession(async_engine) as sess:\n        # async with asynccontextmanager(get_session)() as sess:\n        #     user = await User.get_by_email(sess, 'admin@gmail.com', skip_cache=True)\n        def _attach(name_: str) -&gt; list[str]:\n            neg_ = f'-{name_}'\n            perms_ = set(recipient.permissions)\n\n            if neg_ in perms_:\n                perms_.remove(neg_)\n            elif name_ not in perms_:\n                perms_.add(name_)\n            return list(perms_)\n\n        if not await self.has('permission.attach'):\n            raise PermissionsException()\n\n        if not perm.strip():\n            return\n\n        if not self.is_super and self.email == recipient.email:\n            raise AppException('ILLEGAL_ACTION: You cannot modify your own permissions.')\n\n        permissions = _attach(perm)\n        recipient.permissions = permissions\n        await session.commit()\n\n        if caching:\n            caching(recipient.email, permissions)\n        if async_callback:\n            await async_callback(recipient.email, permissions)\n\n    async def detach_permission(self, session: AsyncSession, recipient: Self, perm: str,\n                                *, caching: Callable[[str, list], None] | None = None,\n                                async_callback: Callable[[str, list], Awaitable[None]] | None = None):\n        \"\"\"\n        Remove a permission from user. If the permission is a starter group (can't be removed) then a negation is added.\n        :param session:     AsyncSession\n        :param recipient:   The user who's group is to be removed\n        :param perm:        Permission\n        :param caching:     Callback for caching data\n        :param async_callback:    Async callback for generic use\n        :raises PermissionsException:\n        :return:            None\n        \"\"\"\n        def _detach(perm_: str) -&gt; list[str]:\n            neg_ = f'-{perm_}'\n            perms_ = set(recipient.permissions)\n\n            if perm_ in perms_:\n                perms_.remove(perm_)\n            else:\n                perms_.add(neg_)\n            return list(perms_)\n\n        if not await self.has('permission.detach'):\n            raise PermissionsException()\n\n        if not perm.strip():\n            return\n\n        if not self.is_super and self.email == recipient.email:\n            raise AppException('ILLEGAL_ACTION: You cannot modify your own permissions.')\n\n        permissions = _detach(perm)\n        recipient.permissions = permissions\n        await session.commit()\n\n        if caching:\n            caching(recipient.email, list(permissions))\n        if async_callback:\n            await async_callback(recipient.email, list(permissions))\n\n    # TESTME: Untested\n    async def ban(self, session: AsyncSession, recipient: Self,\n                  *, caching: Callable[[str, datetime], None] | None = None,\n                  async_callback: Callable[[str, datetime], Awaitable[None]] | None = None):\n        \"\"\"\n        Ban user.\n        :param session:     AsyncSession\n        :param recipient:   The user to ban\n        :param caching:     Callback for caching data\n        :param async_callback:    Async callback for generic use\n        :raises PermissionsException:\n        :return:            None\n        \"\"\"\n        if not await self.has('ban.attach'):\n            raise PermissionsException()\n\n        if recipient.banned_at is not None or self.email == recipient.email:\n            return\n\n        now = arrow.utcnow().datetime\n        recipient.banned_at = now\n        await session.commit()\n\n        if caching:\n            caching(recipient.email, now)\n        if async_callback:\n            await async_callback(recipient.email, now)\n\n    # TESTME: Untested\n    async def unban(self, session: AsyncSession, recipient: Self,\n                    *, caching: Callable[[str, None], None] | None = None,\n                    async_callback: Callable[[str, None], Awaitable[None]] | None = None):\n        \"\"\"\n        Unban user.\n        :param session:     AsyncSession\n        :param recipient:   The user to unban\n        :param caching:     Callback for caching data\n        :param async_callback:    Async callback for generic use\n        :raises PermissionsException:\n        :return:            None\n        \"\"\"\n        if not await self.has('ban.detach'):\n            raise PermissionsException()\n\n        if recipient.banned_at is None or self.email == recipient.email:\n            return\n\n        recipient.banned_at = None\n        await session.commit()\n\n        if caching:\n            caching(recipient.email, None)\n        if async_callback:\n            await async_callback(recipient.email, None)\n</code></pre>"},{"location":"models/usermod/#fastbase.models.UserMod-attributes","title":"Attributes","text":""},{"location":"models/usermod/#fastbase.models.UserMod.banned_at","title":"<code>banned_at: datetime | None = Field(sa_column=Column(DateTime(timezone=True), nullable=True, index=True))</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"models/usermod/#fastbase.models.UserMod.display","title":"<code>display: str = Field(max_length=199)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"models/usermod/#fastbase.models.UserMod.email","title":"<code>email: str = Field(max_length=190, unique=True)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"models/usermod/#fastbase.models.UserMod.groups","title":"<code>groups: list[str] = Field(sa_column=Column(ARRAY(String)), default=[])</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"models/usermod/#fastbase.models.UserMod.is_active","title":"<code>is_active: bool = Field(default=True)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"models/usermod/#fastbase.models.UserMod.is_super","title":"<code>is_super: bool</code>  <code>property</code>","text":""},{"location":"models/usermod/#fastbase.models.UserMod.is_verified","title":"<code>is_verified: bool = Field(default=True)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"models/usermod/#fastbase.models.UserMod.permissions","title":"<code>permissions: list[str] = Field(sa_column=Column(ARRAY(String)), default=[])</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"models/usermod/#fastbase.models.UserMod.role","title":"<code>role: str = Field(max_length=20, default='user')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"models/usermod/#fastbase.models.UserMod.timezone","title":"<code>timezone: str | None = Field(max_length=190, default='+0000')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"models/usermod/#fastbase.models.UserMod.username","title":"<code>username: str = Field(max_length=190, unique=True)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"models/usermod/#fastbase.models.UserMod-functions","title":"Functions","text":""},{"location":"models/usermod/#fastbase.models.UserMod.__repr__","title":"<code>__repr__()</code>","text":"Source code in <code>fastbase/models/UserMod.py</code> <pre><code>def __repr__(self):\n    return modstr(self, 'email')\n</code></pre>"},{"location":"models/usermod/#fastbase.models.UserMod.attach_group","title":"<code>attach_group(session, recipient, name, *, caching=None, async_callback=None)</code>  <code>async</code>","text":"<p>Attach a group to user. Prevents duplicates.</p> PARAMETER  DESCRIPTION <code>session</code> <p>AsyncSession</p> <p> TYPE: <code>AsyncSession</code> </p> <code>recipient</code> <p>The user to recieve the group</p> <p> TYPE: <code>Self</code> </p> <code>name</code> <p>Group name</p> <p> TYPE: <code>str</code> </p> <code>caching</code> <p>Callback for caching data</p> <p> TYPE: <code>Callable[[str, list], None] | None</code> DEFAULT: <code>None</code> </p> <code>async_callback</code> <p>Async callback for generic use</p> <p> TYPE: <code>Callable[[str, list], Awaitable[None]] | None</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <p>None</p> RAISES DESCRIPTION <code>PermissionsException</code> Source code in <code>fastbase/models/UserMod.py</code> <pre><code>async def attach_group(self, session: AsyncSession, recipient: Self, name: str,\n                       *, caching: Callable[[str, list], None] | None = None,\n                       async_callback: Callable[[str, list], Awaitable[None]] | None = None):\n    \"\"\"\n    Attach a group to user. Prevents duplicates.\n    :param session:     AsyncSession\n    :param recipient:   The user to recieve the group\n    :param name:        Group name\n    :param caching:     Callback for caching data\n    :param async_callback:    Async callback for generic use\n    :raises PermissionsException:\n    :return:            None\n    \"\"\"\n    # async with AsyncSession(async_engine) as sess:\n    # async with asynccontextmanager(get_session)() as sess:\n    #     user = await User.get_by_email(sess, 'admin@gmail.com', skip_cache=True)\n    def _attach(name_: str) -&gt; list[str]:\n        neg_ = f'-{name_}'\n        groups_ = set(recipient.groups)\n\n        if neg_ in groups_:\n            groups_.remove(neg_)\n        elif name_ not in groups_:\n            groups_.add(name_)\n        return list(groups_)\n\n    if not await self.has('group.attach'):\n        raise PermissionsException()\n\n    if not name.strip():\n        return\n\n    if not self.is_super and self.email == recipient.email:\n        raise AppException('ILLEGAL_ACTION: You cannot modify your own groups.')\n\n    groups = _attach(name)\n    recipient.groups = groups\n    await session.commit()\n\n    if caching:\n        caching(recipient.email, groups)\n    if async_callback:\n        await async_callback(recipient.email, groups)\n</code></pre>"},{"location":"models/usermod/#fastbase.models.UserMod.attach_permission","title":"<code>attach_permission(session, recipient, perm, *, caching=None, async_callback=None)</code>  <code>async</code>","text":"<p>Attach a permission to user. Prevents duplicates.</p> PARAMETER  DESCRIPTION <code>session</code> <p>AsyncSession</p> <p> TYPE: <code>AsyncSession</code> </p> <code>recipient</code> <p>The user to recieve the group</p> <p> TYPE: <code>Self</code> </p> <code>perm</code> <p>Permission</p> <p> TYPE: <code>str</code> </p> <code>caching</code> <p>Callback for caching data</p> <p> TYPE: <code>Callable[[str, list], None] | None</code> DEFAULT: <code>None</code> </p> <code>async_callback</code> <p>Async callback for generic use</p> <p> TYPE: <code>Callable[[str, list], Awaitable[None]] | None</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <p>None</p> RAISES DESCRIPTION <code>PermissionsException</code> Source code in <code>fastbase/models/UserMod.py</code> <pre><code>async def attach_permission(self, session: AsyncSession, recipient: Self, perm: str,\n                            *, caching: Callable[[str, list], None] | None = None,\n                            async_callback: Callable[[str, list], Awaitable[None]] | None = None):\n    \"\"\"\n    Attach a permission to user. Prevents duplicates.\n    :param session:     AsyncSession\n    :param recipient:   The user to recieve the group\n    :param perm:        Permission\n    :param caching:     Callback for caching data\n    :param async_callback:    Async callback for generic use\n    :raises PermissionsException:\n    :return:            None\n    \"\"\"\n    # async with AsyncSession(async_engine) as sess:\n    # async with asynccontextmanager(get_session)() as sess:\n    #     user = await User.get_by_email(sess, 'admin@gmail.com', skip_cache=True)\n    def _attach(name_: str) -&gt; list[str]:\n        neg_ = f'-{name_}'\n        perms_ = set(recipient.permissions)\n\n        if neg_ in perms_:\n            perms_.remove(neg_)\n        elif name_ not in perms_:\n            perms_.add(name_)\n        return list(perms_)\n\n    if not await self.has('permission.attach'):\n        raise PermissionsException()\n\n    if not perm.strip():\n        return\n\n    if not self.is_super and self.email == recipient.email:\n        raise AppException('ILLEGAL_ACTION: You cannot modify your own permissions.')\n\n    permissions = _attach(perm)\n    recipient.permissions = permissions\n    await session.commit()\n\n    if caching:\n        caching(recipient.email, permissions)\n    if async_callback:\n        await async_callback(recipient.email, permissions)\n</code></pre>"},{"location":"models/usermod/#fastbase.models.UserMod.ban","title":"<code>ban(session, recipient, *, caching=None, async_callback=None)</code>  <code>async</code>","text":"<p>Ban user.</p> PARAMETER  DESCRIPTION <code>session</code> <p>AsyncSession</p> <p> TYPE: <code>AsyncSession</code> </p> <code>recipient</code> <p>The user to ban</p> <p> TYPE: <code>Self</code> </p> <code>caching</code> <p>Callback for caching data</p> <p> TYPE: <code>Callable[[str, datetime], None] | None</code> DEFAULT: <code>None</code> </p> <code>async_callback</code> <p>Async callback for generic use</p> <p> TYPE: <code>Callable[[str, datetime], Awaitable[None]] | None</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <p>None</p> RAISES DESCRIPTION <code>PermissionsException</code> Source code in <code>fastbase/models/UserMod.py</code> <pre><code>async def ban(self, session: AsyncSession, recipient: Self,\n              *, caching: Callable[[str, datetime], None] | None = None,\n              async_callback: Callable[[str, datetime], Awaitable[None]] | None = None):\n    \"\"\"\n    Ban user.\n    :param session:     AsyncSession\n    :param recipient:   The user to ban\n    :param caching:     Callback for caching data\n    :param async_callback:    Async callback for generic use\n    :raises PermissionsException:\n    :return:            None\n    \"\"\"\n    if not await self.has('ban.attach'):\n        raise PermissionsException()\n\n    if recipient.banned_at is not None or self.email == recipient.email:\n        return\n\n    now = arrow.utcnow().datetime\n    recipient.banned_at = now\n    await session.commit()\n\n    if caching:\n        caching(recipient.email, now)\n    if async_callback:\n        await async_callback(recipient.email, now)\n</code></pre>"},{"location":"models/usermod/#fastbase.models.UserMod.detach_group","title":"<code>detach_group(session, recipient, name, *, caching=None, async_callback=None)</code>  <code>async</code>","text":"<p>Remove a group from user. If the group is a starter group (can't be removed) then a negation is added.</p> PARAMETER  DESCRIPTION <code>session</code> <p>AsyncSession</p> <p> TYPE: <code>AsyncSession</code> </p> <code>recipient</code> <p>The user who's group is to be removed</p> <p> TYPE: <code>Self</code> </p> <code>name</code> <p>Group name</p> <p> TYPE: <code>str</code> </p> <code>caching</code> <p>Callback for caching data</p> <p> TYPE: <code>Callable[[str, list], None] | None</code> DEFAULT: <code>None</code> </p> <code>async_callback</code> <p>Async callback for generic use</p> <p> TYPE: <code>Callable[[str, list], Awaitable[None]] | None</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <p>None</p> RAISES DESCRIPTION <code>PermissionsException</code> Source code in <code>fastbase/models/UserMod.py</code> <pre><code>async def detach_group(self, session: AsyncSession, recipient: Self, name: str,\n                       *, caching: Callable[[str, list], None] | None = None,\n                       async_callback: Callable[[str, list], Awaitable[None]] | None = None):\n    \"\"\"\n    Remove a group from user. If the group is a starter group (can't be removed) then a negation is added.\n    :param session:     AsyncSession\n    :param recipient:   The user who's group is to be removed\n    :param name:        Group name\n    :param caching:     Callback for caching data\n    :param async_callback:    Async callback for generic use\n    :raises PermissionsException:\n    :return:            None\n    \"\"\"\n    def _detach(name_: str) -&gt; list[str]:\n        neg_ = f'-{name_}'\n        groups_ = set(recipient.groups)\n\n        if name_ in groups_:\n            groups_.remove(name_)\n        else:\n            groups_.add(neg_)\n        return list(groups_)\n\n    if not await self.has('group.detach'):\n        raise PermissionsException()\n\n    if not name.strip():\n        return\n\n    if not self.is_super and self.email == recipient.email:\n        raise AppException('ILLEGAL_ACTION: You cannot modify your own groups.')\n\n    groups = _detach(name)\n    recipient.groups = groups\n    await session.commit()\n\n    if caching:\n        caching(recipient.email, list(groups))\n    if async_callback:\n        await async_callback(recipient.email, list(groups))\n</code></pre>"},{"location":"models/usermod/#fastbase.models.UserMod.detach_permission","title":"<code>detach_permission(session, recipient, perm, *, caching=None, async_callback=None)</code>  <code>async</code>","text":"<p>Remove a permission from user. If the permission is a starter group (can't be removed) then a negation is added.</p> PARAMETER  DESCRIPTION <code>session</code> <p>AsyncSession</p> <p> TYPE: <code>AsyncSession</code> </p> <code>recipient</code> <p>The user who's group is to be removed</p> <p> TYPE: <code>Self</code> </p> <code>perm</code> <p>Permission</p> <p> TYPE: <code>str</code> </p> <code>caching</code> <p>Callback for caching data</p> <p> TYPE: <code>Callable[[str, list], None] | None</code> DEFAULT: <code>None</code> </p> <code>async_callback</code> <p>Async callback for generic use</p> <p> TYPE: <code>Callable[[str, list], Awaitable[None]] | None</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <p>None</p> RAISES DESCRIPTION <code>PermissionsException</code> Source code in <code>fastbase/models/UserMod.py</code> <pre><code>async def detach_permission(self, session: AsyncSession, recipient: Self, perm: str,\n                            *, caching: Callable[[str, list], None] | None = None,\n                            async_callback: Callable[[str, list], Awaitable[None]] | None = None):\n    \"\"\"\n    Remove a permission from user. If the permission is a starter group (can't be removed) then a negation is added.\n    :param session:     AsyncSession\n    :param recipient:   The user who's group is to be removed\n    :param perm:        Permission\n    :param caching:     Callback for caching data\n    :param async_callback:    Async callback for generic use\n    :raises PermissionsException:\n    :return:            None\n    \"\"\"\n    def _detach(perm_: str) -&gt; list[str]:\n        neg_ = f'-{perm_}'\n        perms_ = set(recipient.permissions)\n\n        if perm_ in perms_:\n            perms_.remove(perm_)\n        else:\n            perms_.add(neg_)\n        return list(perms_)\n\n    if not await self.has('permission.detach'):\n        raise PermissionsException()\n\n    if not perm.strip():\n        return\n\n    if not self.is_super and self.email == recipient.email:\n        raise AppException('ILLEGAL_ACTION: You cannot modify your own permissions.')\n\n    permissions = _detach(perm)\n    recipient.permissions = permissions\n    await session.commit()\n\n    if caching:\n        caching(recipient.email, list(permissions))\n    if async_callback:\n        await async_callback(recipient.email, list(permissions))\n</code></pre>"},{"location":"models/usermod/#fastbase.models.UserMod.exists","title":"<code>exists(session, email)</code>  <code>async</code> <code>classmethod</code>","text":"<p>Check if a user exists</p> Source code in <code>fastbase/models/UserMod.py</code> <pre><code>@classmethod\nasync def exists(cls, session: AsyncSession, email: EmailStr) -&gt; bool:\n    \"\"\"Check if a user exists\"\"\"\n    stmt = select(cls.id).where(cls.email == email)\n    execdata = await session.exec(stmt)\n    if _ := execdata.first():\n        return True\n</code></pre>"},{"location":"models/usermod/#fastbase.models.UserMod.get_by_email","title":"<code>get_by_email(session, email)</code>  <code>async</code> <code>classmethod</code>","text":"Source code in <code>fastbase/models/UserMod.py</code> <pre><code>@classmethod\nasync def get_by_email(cls, session: AsyncSession, email: str) -&gt; Type[Self]:\n    raise NotImplementedError()\n</code></pre>"},{"location":"models/usermod/#fastbase.models.UserMod.has","title":"<code>has(data)</code>  <code>async</code>","text":"Source code in <code>fastbase/models/UserMod.py</code> <pre><code>async def has(self, data: str) -&gt; bool:\n    raise NotImplementedError()\n</code></pre>"},{"location":"models/usermod/#fastbase.models.UserMod.unban","title":"<code>unban(session, recipient, *, caching=None, async_callback=None)</code>  <code>async</code>","text":"<p>Unban user.</p> PARAMETER  DESCRIPTION <code>session</code> <p>AsyncSession</p> <p> TYPE: <code>AsyncSession</code> </p> <code>recipient</code> <p>The user to unban</p> <p> TYPE: <code>Self</code> </p> <code>caching</code> <p>Callback for caching data</p> <p> TYPE: <code>Callable[[str, None], None] | None</code> DEFAULT: <code>None</code> </p> <code>async_callback</code> <p>Async callback for generic use</p> <p> TYPE: <code>Callable[[str, None], Awaitable[None]] | None</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <p>None</p> RAISES DESCRIPTION <code>PermissionsException</code> Source code in <code>fastbase/models/UserMod.py</code> <pre><code>async def unban(self, session: AsyncSession, recipient: Self,\n                *, caching: Callable[[str, None], None] | None = None,\n                async_callback: Callable[[str, None], Awaitable[None]] | None = None):\n    \"\"\"\n    Unban user.\n    :param session:     AsyncSession\n    :param recipient:   The user to unban\n    :param caching:     Callback for caching data\n    :param async_callback:    Async callback for generic use\n    :raises PermissionsException:\n    :return:            None\n    \"\"\"\n    if not await self.has('ban.detach'):\n        raise PermissionsException()\n\n    if recipient.banned_at is None or self.email == recipient.email:\n        return\n\n    recipient.banned_at = None\n    await session.commit()\n\n    if caching:\n        caching(recipient.email, None)\n    if async_callback:\n        await async_callback(recipient.email, None)\n</code></pre>"}]}