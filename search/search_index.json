{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Overview","text":""},{"location":"#fastbasedependency","title":"FastbaseDependency","text":"<p>This does something.</p> Source code in <code>fastbase/main.py</code> <pre><code>class FastbaseDependency:\n    \"\"\"\n    This does something.\n    \"\"\"\n    engine: AsyncEngine\n    User: Type[UserMod]\n\n    # TESTME: Untested\n    @staticmethod\n    def verify_idtoken(authorization: Annotated[str, Header()]) -&gt; str:\n        \"\"\"\n        Dependency to verify if an idtoken is valid.\n        :param authorization:   Google idtoken\n        :return:                Token data\n        :raises InvalidToken:\n        \"\"\"\n        try:\n            token = authorization.split(' ')[1]\n            token_data = auth.verify_id_token(token)\n            return token_data.pop('email')\n        except Exception:\n            raise InvalidToken()\n\n    # TESTME: Untested\n    async def current_user(self, email: Annotated[str, Depends(verify_idtoken)]) -&gt; Type[U]:\n        \"\"\"\n        Dependency for getting the user by their verified idtoken.\n        :param email:   Email taken from the idtoken\n        :return:        User\n        :raises UserNotFoundError:\n        \"\"\"\n        return await self._current_user(email)\n\n    # TESTME: Untested\n    async def _current_user(self, email: str) -&gt; Type[U]:\n        \"\"\"\n        Get user by email for use in dependencies.\n        :param email:   Email taken from the idtoken\n        :return:        User\n        :raises UserNotFoundError:\n        \"\"\"\n        try:\n            async with AsyncSession(self.engine) as session:\n                user = await self.User.get_by_email(session, email)\n                return user\n        except Exception as _:\n            raise UserNotFoundError()\n</code></pre>"},{"location":"#fastbase.FastbaseDependency-attributes","title":"Attributes","text":""},{"location":"#fastbase.FastbaseDependency.User","title":"<code>User: Type[UserMod]</code>  <code>instance-attribute</code>","text":""},{"location":"#fastbase.FastbaseDependency.engine","title":"<code>engine: AsyncEngine</code>  <code>instance-attribute</code>","text":""},{"location":"#fastbase.FastbaseDependency-functions","title":"Functions","text":""},{"location":"#fastbase.FastbaseDependency.current_user","title":"<code>current_user(email)</code>  <code>async</code>","text":"<p>Dependency for getting the user by their verified idtoken.</p> PARAMETER  DESCRIPTION <code>email</code> <p>Email taken from the idtoken</p> <p> TYPE: <code>Annotated[str, Depends(verify_idtoken)]</code> </p> RETURNS DESCRIPTION <code>Type[U]</code> <p>User</p> RAISES DESCRIPTION <code>UserNotFoundError</code> Source code in <code>fastbase/main.py</code> <pre><code>async def current_user(self, email: Annotated[str, Depends(verify_idtoken)]) -&gt; Type[U]:\n    \"\"\"\n    Dependency for getting the user by their verified idtoken.\n    :param email:   Email taken from the idtoken\n    :return:        User\n    :raises UserNotFoundError:\n    \"\"\"\n    return await self._current_user(email)\n</code></pre>"},{"location":"#fastbase.FastbaseDependency.verify_idtoken","title":"<code>verify_idtoken(authorization)</code>  <code>staticmethod</code>","text":"<p>Dependency to verify if an idtoken is valid.</p> PARAMETER  DESCRIPTION <code>authorization</code> <p>Google idtoken</p> <p> TYPE: <code>Annotated[str, Header()]</code> </p> RETURNS DESCRIPTION <code>str</code> <p>Token data</p> RAISES DESCRIPTION <code>InvalidToken</code> Source code in <code>fastbase/main.py</code> <pre><code>@staticmethod\ndef verify_idtoken(authorization: Annotated[str, Header()]) -&gt; str:\n    \"\"\"\n    Dependency to verify if an idtoken is valid.\n    :param authorization:   Google idtoken\n    :return:                Token data\n    :raises InvalidToken:\n    \"\"\"\n    try:\n        token = authorization.split(' ')[1]\n        token_data = auth.verify_id_token(token)\n        return token_data.pop('email')\n    except Exception:\n        raise InvalidToken()\n</code></pre>"},{"location":"#fastbase","title":"Fastbase","text":"<p>             Bases: <code>FastbaseDependency</code></p> Source code in <code>fastbase/main.py</code> <pre><code>class Fastbase(FastbaseDependency):\n    _instance = None\n    _lock = threading.Lock()\n    engine: AsyncEngine\n    redis: Redis | None\n    User: Type[UserMod]\n    user_defaults: dict\n    post_create: Callable[[AsyncSession, UserMod], Awaitable[None]]\n\n\n    def __new__(cls):\n        \"\"\"Singleton pattern\"\"\"\n        if cls._instance is None:\n            with cls._lock:\n                if not cls._instance:\n                    cls._instance = super().__new__(cls)\n        return cls._instance\n\n    # TESTME: Untested\n    def initialize(self, *,\n                   engine: AsyncEngine,\n                   redis: Redis | None = None,\n                   user_model: Type[UserMod],\n                   user_defaults: dict | None = None,\n                   post_create: Callable[[AsyncSession, U], Awaitable[None]] | None = None):\n        \"\"\"Use instead of __init__ since it uses the singleton pattern.\"\"\"\n        self.engine = engine\n        self.redis = redis\n        self.User = user_model\n        self.user_defaults = user_defaults or {}\n        self.post_create = post_create\n\n\n    # TESTME: Untested\n    def get_signin_router(self, user_schema: Type[UserBaseSchema] = UserBaseSchema):\n        \"\"\"\n        Router for when user signs in. An account is created in the db if the user doesn't exist.\n        :param user_schema: Response model\n        :return:\n        \"\"\"\n        router = APIRouter()\n\n        @router.post('/signin', response_model=user_schema)\n        async def signin(token: Annotated[str, Body(embed=True)]) -&gt; Type[Self]:\n            try:\n                token_data = auth.verify_id_token(token)\n            except Exception:\n                raise InvalidToken()\n\n            if email := token_data.get('email'):\n                async with AsyncSession(self.engine) as session:\n                    exists = await self.User.exists(session, EmailStr(email))   # noqa\n\n                    if not exists:\n                        display, *_ = email.partition('@')\n                        user = self.User(email=email, display=display, username=email, **self.user_defaults)\n                        session.add(user)\n                        await session.commit()\n                        await session.refresh(user)\n\n                        if self.post_create:\n                            try:\n                                await self.post_create(session, user)\n                            except Exception:\n                                raise CallbackError()\n                    else:\n                        user = await self.User.get_by_email(session, email)\n                    return user\n            raise InvalidToken()\n        return router\n</code></pre>"},{"location":"#fastbase.Fastbase-attributes","title":"Attributes","text":""},{"location":"#fastbase.Fastbase.User","title":"<code>User: Type[UserMod]</code>  <code>instance-attribute</code>","text":""},{"location":"#fastbase.Fastbase.engine","title":"<code>engine: AsyncEngine</code>  <code>instance-attribute</code>","text":""},{"location":"#fastbase.Fastbase.post_create","title":"<code>post_create: Callable[[AsyncSession, UserMod], Awaitable[None]]</code>  <code>instance-attribute</code>","text":""},{"location":"#fastbase.Fastbase.redis","title":"<code>redis: Redis | None</code>  <code>instance-attribute</code>","text":""},{"location":"#fastbase.Fastbase.user_defaults","title":"<code>user_defaults: dict</code>  <code>instance-attribute</code>","text":""},{"location":"#fastbase.Fastbase-functions","title":"Functions","text":""},{"location":"#fastbase.Fastbase.__new__","title":"<code>__new__()</code>","text":"<p>Singleton pattern</p> Source code in <code>fastbase/main.py</code> <pre><code>def __new__(cls):\n    \"\"\"Singleton pattern\"\"\"\n    if cls._instance is None:\n        with cls._lock:\n            if not cls._instance:\n                cls._instance = super().__new__(cls)\n    return cls._instance\n</code></pre>"},{"location":"#fastbase.Fastbase.get_signin_router","title":"<code>get_signin_router(user_schema=UserBaseSchema)</code>","text":"<p>Router for when user signs in. An account is created in the db if the user doesn't exist.</p> PARAMETER  DESCRIPTION <code>user_schema</code> <p>Response model</p> <p> TYPE: <code>Type[UserBaseSchema]</code> DEFAULT: <code>UserBaseSchema</code> </p> RETURNS DESCRIPTION Source code in <code>fastbase/main.py</code> <pre><code>def get_signin_router(self, user_schema: Type[UserBaseSchema] = UserBaseSchema):\n    \"\"\"\n    Router for when user signs in. An account is created in the db if the user doesn't exist.\n    :param user_schema: Response model\n    :return:\n    \"\"\"\n    router = APIRouter()\n\n    @router.post('/signin', response_model=user_schema)\n    async def signin(token: Annotated[str, Body(embed=True)]) -&gt; Type[Self]:\n        try:\n            token_data = auth.verify_id_token(token)\n        except Exception:\n            raise InvalidToken()\n\n        if email := token_data.get('email'):\n            async with AsyncSession(self.engine) as session:\n                exists = await self.User.exists(session, EmailStr(email))   # noqa\n\n                if not exists:\n                    display, *_ = email.partition('@')\n                    user = self.User(email=email, display=display, username=email, **self.user_defaults)\n                    session.add(user)\n                    await session.commit()\n                    await session.refresh(user)\n\n                    if self.post_create:\n                        try:\n                            await self.post_create(session, user)\n                        except Exception:\n                            raise CallbackError()\n                else:\n                    user = await self.User.get_by_email(session, email)\n                return user\n        raise InvalidToken()\n    return router\n</code></pre>"},{"location":"#fastbase.Fastbase.initialize","title":"<code>initialize(*, engine, redis=None, user_model, user_defaults=None, post_create=None)</code>","text":"<p>Use instead of init since it uses the singleton pattern.</p> Source code in <code>fastbase/main.py</code> <pre><code>def initialize(self, *,\n               engine: AsyncEngine,\n               redis: Redis | None = None,\n               user_model: Type[UserMod],\n               user_defaults: dict | None = None,\n               post_create: Callable[[AsyncSession, U], Awaitable[None]] | None = None):\n    \"\"\"Use instead of __init__ since it uses the singleton pattern.\"\"\"\n    self.engine = engine\n    self.redis = redis\n    self.User = user_model\n    self.user_defaults = user_defaults or {}\n    self.post_create = post_create\n</code></pre>"},{"location":"#usermod","title":"UserMod","text":"<p>             Bases: <code>DTMixin</code>, <code>UuidPK</code>, <code>SQLModel</code></p> Source code in <code>fastbase/models/UserMod.py</code> <pre><code>class UserMod(DTMixin, UuidPK, SQLModel):\n    email: str = Field(max_length=190, unique=True)\n    username: str = Field(max_length=190, unique=True)\n    display: str = Field(max_length=199)\n    timezone: str | None = Field(max_length=190, default='+0000')\n\n    role: str = Field(max_length=20, default='user')\n    groups: list[str] = Field(sa_column=Column(ARRAY(String)), default=[])\n    permissions: list[str] = Field(sa_column=Column(ARRAY(String)), default=[])\n\n    is_verified: bool = Field(default=True)                     # TODO: Optional verification\n    is_active: bool = Field(default=True)                       # TODO: Optional activation\n    banned_at: datetime | None = Field(sa_column=Column(DateTime(timezone=True), nullable=True, index=True))\n\n    def __repr__(self):\n        return modstr(self, 'email')\n\n    # TESTME: Untested\n    @classmethod\n    async def get_by_email(cls, session: AsyncSession, email: str) -&gt; Type[Self]:\n        \"\"\"\n        Get User by their email.\n        :param session:     session\n        :param email:       User email\n        :return:            User\n        :raises NoResultFound: User doesn't exist\n        \"\"\"\n        stmt = select(cls).where(cls.email == email)\n        execdata = await session.exec(stmt)\n        data = execdata.one()\n        return data\n\n    # TESTME: Untested\n    @classmethod\n    async def get_by_id(cls, session: AsyncSession, uid: str) -&gt; Type[Self]:\n        \"\"\"\n        Get User by their id.\n        :param session:     session\n        :param uid:         User id\n        :return:            User\n        :raises NoResultFound: User doesn't exist\n        \"\"\"\n        data = await session.get(cls, UUID(uid))\n        return data\n\n    # TESTME: Untested\n    @classmethod\n    async def exists(cls, session: AsyncSession, email: EmailStr) -&gt; bool:\n        \"\"\"Check if a user exists\"\"\"\n        stmt = select(cls.id).where(cls.email == email)\n        execdata = await session.exec(stmt)\n        if _ := execdata.first():\n            return True\n\n    # TESTME: Untested\n    async def attach_group(self, session: AsyncSession, name: str,\n                           *, caching: Callable[[str, list], None] | None = None,\n                           async_callback: Callable[[str, list], Awaitable[None]] | None = None, ):\n        \"\"\"\n        Add group to user. Removes duplicates.\n        :param session:     AsyncSession\n        :param name:        Group name\n        :param caching:     Callback for caching data\n        :param async_callback:    Async callback for generic use\n        :return:            None\n        \"\"\"\n        # async with AsyncSession(async_engine) as sess: # noqa\n        # async with asynccontextmanager(get_session)() as sess: # noqa\n        #     user = await User.get_by_email(sess, 'admin@gmail.com', skip_cache=True)\n        if name not in self.groups:\n            groups = list({*self.groups, name})\n            self.groups = groups\n            await session.commit()\n\n            if caching:\n                caching(self.email, groups)\n            if async_callback:\n                await async_callback(self.email, groups)\n\n            return groups\n\n    # TESTME: Untested\n    async def detach_group(self, session: AsyncSession, name: str,\n                           *, caching: Callable[[str, list], None] | None = None,\n                           async_callback: Callable[[str, list], Awaitable[None]] | None = None) -&gt; set[str]:\n        \"\"\"\n        Remove group from user.\n        :param session:     AsyncSession\n        :param name:        Group name\n        :param caching:     Callback for caching data\n        :param async_callback:    Async callback for generic use\n        :return:            None\n        \"\"\"\n        if name in self.groups:\n            groups = set(self.groups)\n            groups.discard(name)\n            self.groups = list(groups)\n            await session.commit()\n\n            if caching:\n                caching(self.email, list(groups))\n            if async_callback:\n                await async_callback(self.email, list(groups))\n            return groups\n</code></pre>"},{"location":"#fastbase.UserMod-attributes","title":"Attributes","text":""},{"location":"#fastbase.UserMod.banned_at","title":"<code>banned_at: datetime | None = Field(sa_column=Column(DateTime(timezone=True), nullable=True, index=True))</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"#fastbase.UserMod.display","title":"<code>display: str = Field(max_length=199)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"#fastbase.UserMod.email","title":"<code>email: str = Field(max_length=190, unique=True)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"#fastbase.UserMod.groups","title":"<code>groups: list[str] = Field(sa_column=Column(ARRAY(String)), default=[])</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"#fastbase.UserMod.is_active","title":"<code>is_active: bool = Field(default=True)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"#fastbase.UserMod.is_verified","title":"<code>is_verified: bool = Field(default=True)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"#fastbase.UserMod.permissions","title":"<code>permissions: list[str] = Field(sa_column=Column(ARRAY(String)), default=[])</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"#fastbase.UserMod.role","title":"<code>role: str = Field(max_length=20, default='user')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"#fastbase.UserMod.timezone","title":"<code>timezone: str | None = Field(max_length=190, default='+0000')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"#fastbase.UserMod.username","title":"<code>username: str = Field(max_length=190, unique=True)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"#fastbase.UserMod-functions","title":"Functions","text":""},{"location":"#fastbase.UserMod.__repr__","title":"<code>__repr__()</code>","text":"Source code in <code>fastbase/models/UserMod.py</code> <pre><code>def __repr__(self):\n    return modstr(self, 'email')\n</code></pre>"},{"location":"#fastbase.UserMod.attach_group","title":"<code>attach_group(session, name, *, caching=None, async_callback=None)</code>  <code>async</code>","text":"<p>Add group to user. Removes duplicates.</p> PARAMETER  DESCRIPTION <code>session</code> <p>AsyncSession</p> <p> TYPE: <code>AsyncSession</code> </p> <code>name</code> <p>Group name</p> <p> TYPE: <code>str</code> </p> <code>caching</code> <p>Callback for caching data</p> <p> TYPE: <code>Callable[[str, list], None] | None</code> DEFAULT: <code>None</code> </p> <code>async_callback</code> <p>Async callback for generic use</p> <p> TYPE: <code>Callable[[str, list], Awaitable[None]] | None</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <p>None</p> Source code in <code>fastbase/models/UserMod.py</code> <pre><code>async def attach_group(self, session: AsyncSession, name: str,\n                       *, caching: Callable[[str, list], None] | None = None,\n                       async_callback: Callable[[str, list], Awaitable[None]] | None = None, ):\n    \"\"\"\n    Add group to user. Removes duplicates.\n    :param session:     AsyncSession\n    :param name:        Group name\n    :param caching:     Callback for caching data\n    :param async_callback:    Async callback for generic use\n    :return:            None\n    \"\"\"\n    # async with AsyncSession(async_engine) as sess: # noqa\n    # async with asynccontextmanager(get_session)() as sess: # noqa\n    #     user = await User.get_by_email(sess, 'admin@gmail.com', skip_cache=True)\n    if name not in self.groups:\n        groups = list({*self.groups, name})\n        self.groups = groups\n        await session.commit()\n\n        if caching:\n            caching(self.email, groups)\n        if async_callback:\n            await async_callback(self.email, groups)\n\n        return groups\n</code></pre>"},{"location":"#fastbase.UserMod.detach_group","title":"<code>detach_group(session, name, *, caching=None, async_callback=None)</code>  <code>async</code>","text":"<p>Remove group from user.</p> PARAMETER  DESCRIPTION <code>session</code> <p>AsyncSession</p> <p> TYPE: <code>AsyncSession</code> </p> <code>name</code> <p>Group name</p> <p> TYPE: <code>str</code> </p> <code>caching</code> <p>Callback for caching data</p> <p> TYPE: <code>Callable[[str, list], None] | None</code> DEFAULT: <code>None</code> </p> <code>async_callback</code> <p>Async callback for generic use</p> <p> TYPE: <code>Callable[[str, list], Awaitable[None]] | None</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>set[str]</code> <p>None</p> Source code in <code>fastbase/models/UserMod.py</code> <pre><code>async def detach_group(self, session: AsyncSession, name: str,\n                       *, caching: Callable[[str, list], None] | None = None,\n                       async_callback: Callable[[str, list], Awaitable[None]] | None = None) -&gt; set[str]:\n    \"\"\"\n    Remove group from user.\n    :param session:     AsyncSession\n    :param name:        Group name\n    :param caching:     Callback for caching data\n    :param async_callback:    Async callback for generic use\n    :return:            None\n    \"\"\"\n    if name in self.groups:\n        groups = set(self.groups)\n        groups.discard(name)\n        self.groups = list(groups)\n        await session.commit()\n\n        if caching:\n            caching(self.email, list(groups))\n        if async_callback:\n            await async_callback(self.email, list(groups))\n        return groups\n</code></pre>"},{"location":"#fastbase.UserMod.exists","title":"<code>exists(session, email)</code>  <code>async</code> <code>classmethod</code>","text":"<p>Check if a user exists</p> Source code in <code>fastbase/models/UserMod.py</code> <pre><code>@classmethod\nasync def exists(cls, session: AsyncSession, email: EmailStr) -&gt; bool:\n    \"\"\"Check if a user exists\"\"\"\n    stmt = select(cls.id).where(cls.email == email)\n    execdata = await session.exec(stmt)\n    if _ := execdata.first():\n        return True\n</code></pre>"},{"location":"#fastbase.UserMod.get_by_email","title":"<code>get_by_email(session, email)</code>  <code>async</code> <code>classmethod</code>","text":"<p>Get User by their email.</p> PARAMETER  DESCRIPTION <code>session</code> <p>session</p> <p> TYPE: <code>AsyncSession</code> </p> <code>email</code> <p>User email</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>Type[Self]</code> <p>User</p> RAISES DESCRIPTION <code>NoResultFound</code> <p>User doesn't exist</p> Source code in <code>fastbase/models/UserMod.py</code> <pre><code>@classmethod\nasync def get_by_email(cls, session: AsyncSession, email: str) -&gt; Type[Self]:\n    \"\"\"\n    Get User by their email.\n    :param session:     session\n    :param email:       User email\n    :return:            User\n    :raises NoResultFound: User doesn't exist\n    \"\"\"\n    stmt = select(cls).where(cls.email == email)\n    execdata = await session.exec(stmt)\n    data = execdata.one()\n    return data\n</code></pre>"},{"location":"#fastbase.UserMod.get_by_id","title":"<code>get_by_id(session, uid)</code>  <code>async</code> <code>classmethod</code>","text":"<p>Get User by their id.</p> PARAMETER  DESCRIPTION <code>session</code> <p>session</p> <p> TYPE: <code>AsyncSession</code> </p> <code>uid</code> <p>User id</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>Type[Self]</code> <p>User</p> RAISES DESCRIPTION <code>NoResultFound</code> <p>User doesn't exist</p> Source code in <code>fastbase/models/UserMod.py</code> <pre><code>@classmethod\nasync def get_by_id(cls, session: AsyncSession, uid: str) -&gt; Type[Self]:\n    \"\"\"\n    Get User by their id.\n    :param session:     session\n    :param uid:         User id\n    :return:            User\n    :raises NoResultFound: User doesn't exist\n    \"\"\"\n    data = await session.get(cls, UUID(uid))\n    return data\n</code></pre>"},{"location":"aaa/","title":"Aaa","text":"<p>oensuthenot</p>"}]}